# [6-1] 정렬

## 1. 선택 정렬

#### 💡 알고리즘

처리되지 않은 데이터 중에서 **가장 작은 데이터**를 **선택**해 맨 앞에 있는 데이터와 바꾸는 것을 반복

- 단계를 반복할 때마다 탐색 범위가 줄어들며, 해당 범위 내에서 가장 작은 데이터를 찾기 위해 매번 선형 시간이 소요된다.

  > 이중 for 문으로 구현 가능

- 마지막 하나의 원소만 남을 경우, 이동할 필요가 없으므로 정렬을 수행하지 않는다.

```python
array = [7,5,9,0,3,1,6,2,4,8]

for i in range(len(array)):
    min_index = i
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] #스와프

print(array)
```

> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]



### ⏰ 시간 복잡도

- N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.

  > N + (N-1) + (N-2) + ... + 2

- **O(N^2)**





## 2. 삽입 정렬

처리 되지 않은 데이터를 하나씩 골라 **적절한 위치**에 **삽입**한다. 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작한다.



#### 💡 알고리즘

- 현재 차례 왼쪽의 데이터들은 이미 정렬되어 있다고 판단한다. 현재 차례의 데이터를 왼쪽의 데이터들과 차례로 크기를 비교하며 자신보다 작은 데이터가 나올때까지 위치를 바꾸어 나간다.

```python
array = [7,5,9,0,3,1,6,2,4,8]

for i in range(1, len(array)):
    for j in range(i,0,-1): # 인덱스 i부터 1까지 1씩 감소하며 반복
        if array[j] < array[j-1]: # 한 칸씩 왼쪽으로 이동
            array[j], array[j-1] = array[j-1], array[j]
        else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break

print(array)
```

> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]



#### ⏰ 시간 복잡도

- **O(N^2)**

  > 반복문이 두 번 중첩되어 사용

- 현재 리스트의 데이터가 *거의 정렬되어 있는 상태라면 매우 빠르게 동작*한다.

  - 최선의 경우 **O(N)**

    > 원래 각 차례의 데이터마다 앞 데이터들과 비교하는데에 선형시간이 소요되는데, 이미 정렬되어있을 경우 모든 데이터들이 바로 왼쪽의 데이터와 비교만 하고 멈추므로, 상수시간이 소요된다. 따라서 전체  탐색 시간은 O(N) 이다.





## 3. 퀵 정렬

- 기준 데이터를 설정하고, **그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)**으로 설정



#### 💡 알고리즘

- 왼쪽에서부터 첫번째로 찾은 피벗 값보다 큰 데이터를 선택하고, 오른쪽에서부터 피벗 값보다 작은 데이터를 선택한다. 이후 두 데이터의 위치를 서로 변경한다. 
- 위 과정을 반복해나는데, 위치가 엇갈리는 경우 '피벗'과 '작은 데이터'의 위치를 서로 변경한다. 
- 이후 피벗 값 왼쪽에 있는 데이터는 모두 피벗값보다 작고, 오른쪽에 있는 데이터는 모두 피벗 값보다 크다. 이렇게 *피벗을 기준으로 데이터 묶음을 나누는 작업*을 **분할(Divide)**이라고한다.

- 왼쪽에 있는 데이터들과, 오른쪽에 있는 데이터들에 대해서  각각 위 과정을 반복한다.

![퀵정렬1](https://t1.daumcdn.net/cfile/tistory/9955DD3F5AFBE0C407)



#### 💻 구현 (Python)

```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array,start,end):
    if start > end:
        return
    pivot = start # 피벗은 첫번째 원소
    left = start + 1
    right = end
    while(left <= right): # 엇갈릴때까지  
        # 왼쪽에서부터 피벗보다 큰 데이터를 찾을 때까지 반복
        while(left <= end and array[left] <= array[pivot]):
            left += 1
        # 오른쪽에서부터 피벗보다 작은 데이터를 찾을 때까지 반복
        while(right > start and array[right] >= array[left]):
            right -= 1
        if(left > right): # 엇갈린다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right]
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)
    
quick_sort(array, 0, len(array) - 1)
print(array)
```



```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return array
    pivot = array[0] # 피벗은 첫 번째 원소
    tail = array[:] # 피벗을 제외한 리스트
    
    left_side = [x for x in tail if x<=pivot] # 분할된 왼쪽 부분
    right_side = [x for x in tail if x>pivot] # 분할된 오른쪽 부분
    
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행하고, 전체 리스트 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side) # 리스트를 붙여서 반환

print(quick_sort(array))
```



#### ⏰ 시간 복잡도

**어떤 원소를 피벗으로 설정하냐에 따라** 시간복잡도가 달라진다.

- 평균의 경우 **O(NlogN)**

> 이상적인 경우, 분할이 절반씩 일어난다면 전체 연산 횟수로 O(NlogN)을 기대할 수 있다.
>
> - 너비 * 높이 = N * logN = NlogN

- 최악의 경우 **O(N^2)**

> ex) 첫 번째 원소를 피벗으로 삼을 때, 이미 정렬된 배열에 대해서 퀵 정렬 수행 시 오른쪽부터 피벗 값 보다 작은 원소를 찾기 위해 첫번째 원소(0)까지 오게 되고, 피벗 값과 첫번째 원소의 자리를 바꾸는 연산(자신과 자신)을 수행하게 된다. 이후 데이터들이 피벗 기준 왼쪽과 오른쪽으로 분할되지 않고, 모두 오른쪽에만 위치하게 되어 오른쪽에 위치한 모든 원소들에 대해 동일한 탐색을 해야한다. 분할을 위해 계속해서 선형 시간(O(N)) 이 소요된다.

![image-20210125130308296](https://user-images.githubusercontent.com/54929552/105689014-99a05f00-5f3d-11eb-9d42-9305b3a6b6f2.png)

- 프로그래밍 라이브러리에서는 최악의 경우에도 O(NlogN) 의 성능을 보이도록 설계하여 지원하고있다.





## 4. 계수 정렬

특정한 조건이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작**하는 정렬 알고리즘

- 계수 정렬은 **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때** 사용 가능
- 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행시간 O(N+K)를 보장한다.



#### 💡 알고리즘

- 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트를 생성한다. 데이터를 하나씩 확인하며 데어터의 값과 동일한 인덱스의 값을 1씩 증가시키고, 최종 리스트에는 각 데이터가 몇 번씩 등장했는지 그 **횟수(count)**가 기록된다.
- 결과를 확인할 때는 리스트의 첫 번째 데이터부터 하나씩 그 값(count)만큼 반복하여 인덱스를 출력하게 되면 정렬을 수행한 것과 같다.



#### 💻 구현 (Python)

```python
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가
    
for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
```

> 0 0 1 1 2 2 3 4 5 5 6 7 8 9 9



#### ⏰ 시간 복잡도

- 계수 정렬의 시간복잡도와 공간복잡도는 모두 **O(N+K)** 이다.

- 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다.

  > ex) 데이터가 0과 999,999로 단 2개만 존재하는 경우

- 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있다.

  > ex) 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 효과적이다. ( 값의 범위가 한정적이고 동일한 데이터가 여러 개 인 경우 )





## 정렬 알고리즘 비교

![image-20210125142826145](https://user-images.githubusercontent.com/54929552/105689121-b63c9700-5f3d-11eb-9b49-4c034b3556e4.png)



> 본 내용은 *이것이 취업을 위한 코딩 테스트다 with 파이썬 - 나동빈* 책을 통하여 학습한 후 정리하였습니다.

