# [9095] 1, 2, 3 더하기

| 시간 제한             | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------------------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 초 (추가 시간 없음) | 512 MB      | 54659 | 34959 | 23215     | 61.915%   |

## 문제

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.

- 1+1+1+1
- 1+1+2
- 1+2+1
- 2+1+1
- 2+2
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.

## 출력

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.





## 💡 구현 아이디어

- 구해야하는 것:  n을 1, 2, 3의 합으로 나타내는 방법의 수

- 규칙을 찾기 위해 경우의 수를 찾아본다.

  - 1: (1) - 1개
  - 2: (1+1), (2) - 2개
  - 3: (1+1+1), (1+2), (2+1), (3) - 4개
  - 4: (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2), (1+3), (3+1) - 7개
  - 5: (1+1+1+1+1), (1+1+1+2), (1+1+2+1), (1+2+1+1), (1+2+2), (1+1+3), (1+3+1), (2+1+1+1), (2+1+2), (2+3), (3+1+1), (3+2) - 13개

  개수의 변화를 통해 d[i] = d[i-3] + d[i-2] + d[i-1] 라는 점화식을 도출해낼 수 있었다.

  합에 사용할 수 있는 수는 1, 2, 3만 가능하므로 n-3 번째의 모든 경우에 3을 더한 것, n-2번째에 2를 더한 것, n-1번째에 1을 더한 것임을 추론 및 확인할 수 있다. 최적 부분 구조를 가지며, 중복되는 부분 문제가 있다 => DP 로 풀어낸다.

- d[n] = d[n-3] + d[n-2] + d[n-1], d[1] = 1, d[2] = 2, d[3] = 4

  > 초기값 예외처리가 필요하다.





## 🙆‍♀️ 내 풀이 (python)

```python
import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
  n = int(input())
  d = [1] * (n+1)
  if n>1: d[2] = 2
  if n>2: d[3] = 4

  for i in range(4,n+1):
    d[i] = d[i-3] + d[i-2] + d[i-1]
    
  print(d[n])
```

