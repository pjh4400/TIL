# [1783] 병든 나이트 분류

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 128 MB      | 6256 | 2701 | 2315      | 43.110%   |

## 문제

병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.

1. 2칸 위로, 1칸 오른쪽
2. 1칸 위로, 2칸 오른쪽
3. 1칸 아래로, 2칸 오른쪽
4. 2칸 아래로, 1칸 오른쪽

병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.

체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.

## 입력

첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.

## 출력

병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.



## 💡 구현 아이디어

- 구해야 하는 것: 여행에서 방문할 수 있는 칸의 **최대 개수**

- 가능한 이동 방향은 **무조건 오른쪽**이다.

  - 열 수에 집중하여 조건을 찾는다.
    - 최대한 많은 칸을 방문하려면 오른쪽으로는 1칸 씩만 이동하는 것이 유리하다.
    - 이동 횟수가 4번이상일 경우에는 4가지 방법을 모두 사용해야하므로 열 수에 비례한다.

- 행 수, 열 수를 증가시켜가면서 그림을 그려가면서 규칙을 찾았다.

  

## 🙆‍♀️ 내 풀이 (python)

```python
n, m = map(int,input().split())

if n == 1:
  print(1)
elif n == 2:
  if m<3: print(1)
  elif m<5: print(2)
  elif m<7: print(3)
  else: print(4)
# 행 수가 2보다 크고 열 수가 4 보다 적은 경우, 오른쪽으로 1씩 이동 가능 하므로 방문 칸 수는 열 수와 동일하다.
elif m < 4:
  print(m)
# 열 수가 4 일때부터 이동 횟수가 4번이 되므로 4가지 이동 방법을 모두 사용할 수 있을 때까지(열 수가 6일 때까지) 동일한 최대 방문 칸 수(4)를 갖는다.
elif m < 7:
  print(4)
# 열 수가 7이상일 때에는 열 수보다 2개 작은 방문 칸 수를 갖는다.
else:
  print(m-2)
```
