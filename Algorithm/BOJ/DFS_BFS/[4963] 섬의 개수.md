# [4963] ì„¬ì˜ ê°œìˆ˜

| ì‹œê°„ ì œí•œ | ë©”ëª¨ë¦¬ ì œí•œ | ì œì¶œ  | ì •ë‹µ  | ë§ì€ ì‚¬ëŒ | ì •ë‹µ ë¹„ìœ¨ |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 ì´ˆ      | 128 MB      | 27235 | 13637 | 9865      | 49.347%   |

## ë¬¸ì œ

ì •ì‚¬ê°í˜•ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆëŠ” ì„¬ê³¼ ë°”ë‹¤ ì§€ë„ê°€ ì£¼ì–´ì§„ë‹¤. ì„¬ì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

![img](https://www.acmicpc.net/upload/images/island.png)

í•œ ì •ì‚¬ê°í˜•ê³¼ ê°€ë¡œ, ì„¸ë¡œ ë˜ëŠ” ëŒ€ê°ì„ ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ì‚¬ê°í˜•ì€ ê±¸ì–´ê°ˆ ìˆ˜ ìˆëŠ” ì‚¬ê°í˜•ì´ë‹¤. 

ë‘ ì •ì‚¬ê°í˜•ì´ ê°™ì€ ì„¬ì— ìˆìœ¼ë ¤ë©´, í•œ ì •ì‚¬ê°í˜•ì—ì„œ ë‹¤ë¥¸ ì •ì‚¬ê°í˜•ìœ¼ë¡œ ê±¸ì–´ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ë¡œê°€ ìˆì–´ì•¼ í•œë‹¤. ì§€ë„ëŠ” ë°”ë‹¤ë¡œ ë‘˜ëŸ¬ì‹¸ì—¬ ìˆìœ¼ë©°, ì§€ë„ ë°–ìœ¼ë¡œ ë‚˜ê°ˆ ìˆ˜ ì—†ë‹¤.

## ì…ë ¥

ì…ë ¥ì€ ì—¬ëŸ¬ ê°œì˜ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤. ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ì²«ì§¸ ì¤„ì—ëŠ” ì§€ë„ì˜ ë„ˆë¹„ wì™€ ë†’ì´ hê°€ ì£¼ì–´ì§„ë‹¤. wì™€ hëŠ” 50ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ì–‘ì˜ ì •ìˆ˜ì´ë‹¤.

ë‘˜ì§¸ ì¤„ë¶€í„° hê°œ ì¤„ì—ëŠ” ì§€ë„ê°€ ì£¼ì–´ì§„ë‹¤. 1ì€ ë•…, 0ì€ ë°”ë‹¤ì´ë‹¤.

ì…ë ¥ì˜ ë§ˆì§€ë§‰ ì¤„ì—ëŠ” 0ì´ ë‘ ê°œ ì£¼ì–´ì§„ë‹¤.

## ì¶œë ¥

ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ëŒ€í•´ì„œ, ì„¬ì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥í•œë‹¤.





## ğŸ’¡ êµ¬í˜„ ì•„ì´ë””ì–´

- êµ¬í•´ì•¼ í•˜ëŠ” ê²ƒ: ì„¬ì˜ ê°œìˆ˜

- ì£¼ì–´ì§„ ì§€ë„ëŠ” í–‰ë ¬ í˜•íƒœì´ë‹¤: ê·¸ë˜í”„íƒìƒ‰ (ì¸ì ‘í–‰ë ¬ ì´ìš©)
- ê°€ë¡œ, ì„¸ë¡œ ë˜ëŠ” ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ ê°€ëŠ¥í•˜ë‹¤. : 8 ë°©í–¥





## ğŸ™†â€â™€ï¸ ë‚´ ì½”ë“œ (python)

```python
import sys
input = sys.stdin.readline

#ìƒ,í•˜,ì¢Œ,ìš°,ì¢Œìƒ,ì¢Œí•˜,ìš°ìƒ,ìš°í•˜
dx = [1,-1,0,0,1,-1,1,-1] #í–‰
dy = [0,0,-1,1,-1,-1,1,1] #ì—´

from collections import deque
def bfs(i,j):
  queue = deque([(i,j)])
  visited[i][j] = True
  while queue:
    x,y = queue.popleft()
    for idx in range(8):
      nx = x + dx[idx]
      ny = y + dy[idx]
      if nx<0 or nx>=h or ny<0 or ny>=w:
        continue
      elif graph[nx][ny] == 1 and not visited[nx][ny]:
        queue.append((nx,ny))
        visited[nx][ny] = True
        
sys.setrecursionlimit(10**6)        
def dfs(i,j):
  visited[i][j] = True
  for idx in range(8):
    nx = i + dx[idx]
    ny = j + dy[idx]
    if nx<0 or nx>=h or ny<0 or ny>=w:
      continue
    elif graph[nx][ny] == 1 and not visited[nx][ny]:
      dfs(nx,ny)  

while True:
  w, h = map(int,input().split())
  if w == 0 and h == 0: # ì¢…ë£Œ ì¡°ê±´
    break
  graph = []
	# ë°©ë¬¸ ì—¬ë¶€ë„ í–‰ë ¬ë¡œ
  visited = [[False]*w for _ in range(h)]
  for _ in range(h):
    graph.append(list(map(int,input().split())))
  count = 0
  for i in range(h):
    for j in range(w):
      if graph[i][j] == 1 and not visited[i][j]:
        bfs(i,j)
        #dfs(i,j)
        count += 1
  print(count)
```

